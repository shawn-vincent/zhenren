Great. I’ll research the best possible way to set up a universal React project that targets mobile, web, and desktop platforms using a single source base with minimal redundant code. I’ll focus on approaches that prioritize code sharing, cross-platform compatibility, and a streamlined developer experience.

I’ll get back to you with a structured summary of the top frameworks, libraries, and best practices for achieving this setup.


# Universal React Architecture for Web, Mobile, and Desktop

Developing a **universal React application** – one codebase that runs on web, mobile, and desktop – can dramatically reduce maintenance overhead and ensure a consistent user experience across platforms. Modern tools like **React Native**, **Expo**, **React Native for Web**, **Next.js**, and **Electron** (among others) offer building blocks to achieve this "write once, run anywhere" vision. This report explores the best architecture for a unified React project targeting **iOS/Android mobile**, **web**, and **desktop**, with minimal code redundancy. We compare key frameworks, libraries, and boilerplates, examining their real-world usage, community support, developer experience (DX), and performance. Finally, we provide recommendations for maximizing code sharing while meeting platform-specific needs.

## Cross-Platform Frameworks and Tools

### React Native (Mobile Cross-Platform Core)

**React Native (RN)** is the foundation of many cross-platform React applications. RN enables building native iOS and Android apps using React and JavaScript, sharing a single codebase between the two mobile platforms. Instead of rendering to HTML DOM, RN uses platform-native UI components (e.g. `<View>` maps to UIKit `UIView` on iOS or Android `View`) via a bridge. This yields near-native performance for most app use cases while allowing developers to use common React patterns. RN’s motto “learn once, write anywhere” reflects that much of the code (business logic, state management, etc.) can be reused across platforms, though some platform-specific tweaking is often needed for truly polished UX.

**Strengths:** RN has a large, active community and a rich ecosystem of libraries and UI kits. Thousands of apps use it in production – from tech giants to startups. Companies like Facebook/Meta, Microsoft, and Amazon have adopted RN at scale for mobile apps, citing faster development and easier maintenance. RN’s cross-platform UI components and modules make it possible to achieve \~90% shared code between iOS and Android in many cases.

**Limitations:** For extremely graphics-intensive or platform-specific scenarios, fully native code can outperform RN (due to the overhead of the RN bridge). Also, when extending beyond mobile (to web or desktop), RN alone isn’t enough – this is where complementary tools like **React Native for Web** and others come into play.

### React Native for Web (Bringing RN to the Browser)

**React Native for Web (RNW)** is an open-source library by Nicolas Gallagher that lets you run React Native components in web browsers using standard web tech. Essentially, it provides web equivalents for RN’s core components and APIs. For example, an RN `<View>` or `<Text>` renders as a HTML `<div>` or `<p>` on the web. By aliasing the `react-native` import to `react-native-web` in a web build, the *same* JSX code can work on mobile (using native widgets) and on web (using DOM elements).

This is a game-changer for code sharing. With RNW, developers can target **Android, iOS, and web** from one codebase. Microsoft has even extended RN to support **Windows and macOS** natively, meaning a single React Native codebase can potentially cover *five* platforms (Android, iOS, web, Windows, macOS). In practice, RNW has been adopted by major companies – **Twitter**, **Flipkart**, **Major League Soccer**, and others – to unify their web and mobile app development. These companies have demonstrated that a well-architected RN codebase can deliver a website and mobile app with shared UI components and logic.

**Benefits:** Using RNW means you **“add web support without a time-consuming rewrite”**, as one source notes. Most third-party RN libraries now support web, so you can often reuse UI kits (React Native Paper, React Native Elements, etc.) in the browser. Styles are also handled seamlessly – RN’s `StyleSheet` API is ported to work with CSS-in-JS under the hood, so your styling code can be shared too. In short, RNW aims to fulfill the “write once, run anywhere” promise by covering the web platform in addition to mobile.

**Challenges:** Complete cross-platform parity is hard; not everything in a mobile app translates to web. Certain mobile-specific APIs or gestures have no web equivalent. Conversely, web demands like responsive layouts and hover effects require additional consideration on mobile. Developers often must introduce a few platform-specific components or style tweaks (e.g. separate files like `Button.web.tsx` vs `Button.ios.tsx`) to account for differences in UX expectations. Still, RNW drastically reduces duplicated effort – one can typically share the majority of UI code and all business logic between web and mobile.

### Expo (Unified Development Workflow)

**Expo** is a framework and toolchain built around React Native that streamlines cross-platform development. It provides a managed ecosystem with a CLI, native module APIs, over-the-air updates, and an app sandbox for easy testing on devices. Expo’s **“universal React”** approach means it supports iOS, Android, and **out-of-the-box web support** via React Native for Web. With Expo, you can run `expo start --web` and get a web app running from your RN code with zero config – even enabling publishing of a Progressive Web App if desired.

Expo shines in **developer experience**: it abstracts the native build complexities, letting developers focus on JavaScript/TypeScript code. It includes a rich SDK of cross-platform modules (for camera, sensors, push notifications, etc.), so you often don’t need to eject or write native code for common features. The development cycle is fast (hot reloading on device or web) and it’s easy to share apps for testing using Expo Go.

**Web and Expo:** Historically, Expo’s web capabilities were less mature than dedicated web frameworks like Next.js. Expo apps can run on the web, but without features like server-side rendering (SSR) or sophisticated routing out of the box. Expo has introduced **Expo Router** (file-based routing) that works for both native and web routing in one structure, which simplifies navigation code sharing. However, as noted in one analysis, Expo Router “may not provide robust functionality for web apps that require SSR for SEO”. In other words, a pure Expo approach is great for an app-like web experience or internal tools, but if your web app needs to be SEO-friendly or handle heavy web traffic, you might integrate Expo with a framework like Next.js (see below).

**Real-world usage:** Expo is popular for startups, MVPs, and even some large apps. It’s backed by a strong community. Many open-source starter kits (Ignite, Obytes Starter, create-expo-stack, etc.) use Expo for the base setup. Developers appreciate Expo’s “write once” ethos: one study case was a team building a design system for both mobile and web, and Expo + RN for Web enabled them to **avoid duplicating components or business logic** in two codebases.

**Trade-offs:** Using Expo means you’re in a managed environment. While Expo now allows adding custom native modules via Development Builds, using certain unsupported native libraries might require “ejecting” from the managed workflow. Additionally, for web-specific needs (like SSR, advanced web analytics integration), you’ll likely complement Expo with other tools. Despite these, Expo is often a top choice to maximize code sharing – it “simplifies the development process, allowing developers to create high-quality, performant apps for iOS, Android, and the web with a single codebase”.

### Next.js (Web Framework for SSR and More)

**Next.js** is a leading React framework for building web applications. It provides features like **server-side rendering (SSR)**, static site generation, API routes, and an intuitive file-system routing. While Next is not a cross-platform tool by itself (it targets web only), it becomes crucial in a universal React stack when we want a **first-class web experience** (especially for public-facing sites where SEO, performance, and deep linking matter).

By integrating Next.js with React Native (via React Native for Web), teams can share UI components and business logic between a Next.js web app and a React Native mobile app. In such an architecture, Next.js handles the web-specific concerns: it renders pages on the server for fast loads and good SEO, handles web routing and asset bundling, etc., while the RN mobile app handles mobile UI. The two share a common library of components (using RNW for the web versions) and modules (utilities, state logic, API clients).

This combination is often managed in a **monorepo** setup. For example, the popular **T3 Stack** (by Theo Brunner) uses a monorepo that includes a Next.js app for web and an Expo/React Native app for mobile, sharing code where possible. Monorepo tools like Turborepo or Nx are used to manage build and dependency sharing between the apps. The result is a unified developer experience: you can work on a component in one package and see changes both in the Next.js web app and the RN mobile app.

**Community & Tools:** Next.js has a massive community and Vercel’s backing. There are recipes and libraries to make Next-RN integration smoother. For instance, Expo provides an **@expo/next-adapter** to configure Next.js to handle RNW and Expo assets. Another library, **Solito**, helps unify navigation/routing between React Navigation (native) and Next.js (web), translating URLs to the appropriate native navigation actions. These tools address the tricky parts of combining these ecosystems.

**Pros:** Using Next.js for the web portion means you don’t sacrifice web performance or SEO while sharing code. You get the best of both: a highly optimized web app and a true native mobile app, with a lot of React component code reused. One developer experience point to note: you will run separate dev servers (one for Next, one for the native app), but with hot-reload in each. Some find this separation clean; others prefer a single unified dev server (which Expo’s pure-web approach would give, at the cost of SSR).

**Cons:** The integration isn’t entirely plug-and-play – some configuration is needed (aliasing modules, ensuring packages are transpiled, etc.). Also, not all design patterns that work in Next (e.g. using certain web-only libraries) will translate to RN, so discipline is required to keep shared code truly cross-platform. Overall, however, the **Next + RN** approach is emerging as a robust solution for companies that need a strong web presence without maintaining a separate tech stack. In practice, many teams report positive results with a Next/Expo monorepo – gaining “code reuse, faster iteration cycles, and enhanced maintainability across web and mobile”.

### Electron (Desktop Applications via Web Tech)

**Electron** is a popular open-source framework for building cross-platform **desktop** applications using web technologies (HTML, CSS, JS). Essentially, Electron wraps a Chromium browser and Node.js runtime into a desktop app container. Developers can load their web app into Electron and distribute it as a Windows, macOS, or Linux application.

For a universal React project, Electron offers a straightforward way to turn your web code into a desktop app **with minimal changes**. If you have a React (or React Native for Web) app running in the browser, it can be packaged into Electron, instantly targeting desktop platforms. Many well-known desktop apps use Electron – for example, **Visual Studio Code, Slack, and Skype are built with Electron** – demonstrating that it can handle complex, high-profile applications.

**Advantages:** The biggest draw is 100% code reuse for desktop. You leverage the exact same React components and logic from your web app. Electron also gives access to native OS features via Node.js modules (file system, menus, notifications, etc.), so you can extend the web app with desktop-specific capabilities as needed. Developer experience is also a plus: web developers can build desktop apps without learning new languages or frameworks. The development process is similar to building a website, and one codebase can serve all desktop OSes.

**Performance Considerations:** Electron has some downsides in resource usage. Each Electron app bundles a Chromium browser, meaning apps can be **memory-heavy**, and the bundle size is large (since essentially you ship a browser with your app). For example, running two Electron apps is like running two separate Chrome instances, which can be RAM intensive. CPU performance is usually fine for most use cases, but for graphics-heavy or very large applications, an Electron app may be less efficient than a truly native desktop app. It’s noted that Electron is “not ideal for apps that require resource-intensive UIs or animations”, whereas a native approach could handle those more smoothly.

**Alternatives for Desktop:** If performance or native fidelity on desktop is paramount, one alternative is to use **React Native for Windows and macOS** (maintained by Microsoft). This would mean writing some desktop-specific RN code (since not all mobile components make sense on desktop), but you still stay within React Native. Microsoft leverages this approach for apps like Teams and Office on desktop, and they officially support RN on Windows/macOS. The benefit is a more native UI (using actual native controls on each OS) and lower memory footprint than Electron. The downside is increased complexity – you need the native development tools for each desktop platform and have to manage some platform-specific code. Community support for RN on desktop is growing but far smaller compared to Electron’s ecosystem.

In summary, for a **universal one-codebase project**: the simplest path to desktop is usually **Electron** (use your shared web app, drop into Electron – done). This maximizes reuse, at the cost of heavier resource usage. If your app needs to be more lightweight or deeply integrated into OS features, consider a **dual approach**: share core logic and maybe some UI, but implement native desktop UIs using RN for Windows/macOS or even platform-specific code. Many Meta products, for example, use React Native across web, mobile, and desktop – the official RN showcase notes that React Native is used to shape **“mobile, web, and desktop experiences”** in products like Facebook Marketplace and Messenger Desktop.

### Alternative Approaches (Web-First with Capacitor/Ionic)

Aside from the React Native-centric stack, another approach is to use **web technology as the single codebase** and deploy it everywhere via wrappers. Tools like **Ionic Framework** or **Capacitor** (by Ionic team) allow a React (DOM) app to be packaged as a native mobile app using a WebView, and similarly wrapped as a desktop app. In this scenario, you would write a standard React web app (with perhaps Ionic’s UI components for mobile-style widgets), then:

* Use **CapacitorJS** to create iOS/Android app shells that load the web app (enabling access to native plugins for camera, etc., via JavaScript). This achieves nearly 100% code sharing between web and mobile since it’s literally the same web UI in a native container.
* Use **Electron** or a lighter alternative like **Tauri** to package the same web app for desktop.

The advantage is maximal code reuse – essentially one React/HTML codebase for all platforms. However, there are trade-offs: apps run in a WebView, so the performance and look-and-feel are that of a web app, not true native. Animations and heavy graphics might not be as smooth as in a React Native app that uses native components. As one analysis puts it, the native experience with this approach “may not match that of React Native, potentially impacting user satisfaction and app performance”. This web-first strategy can be suitable for content-centric apps or enterprise apps where exact native UI isn’t critical, but for consumer-facing apps that demand native fluidity, the React Native approach is often preferred.

## Architectural Considerations for Code Sharing

Achieving a successful universal React project requires thoughtful **architecture** beyond just picking frameworks. Here we outline key decisions and strategies to maximize code sharing while keeping each platform’s experience optimal.

* **Monorepo vs. Multiple Repos:** Most teams opt for a **monorepo** using tools like Yarn Workspaces, Lerna, or Turborepo to house the web and native projects together. This way, you can have shared folders/packages for common code (utils, components, etc.) and separate app folders for the Next.js app, the React Native app, etc. A typical structure might be:

  ```text
  my-universal-app/
   ├── apps/
   │   ├── web/      (Next.js project)
   │   └── native/   (Expo/React Native project)
   └── packages/
       ├── ui/       (shared UI components)
       └── utils/    (shared business logic)
  ```

  Monorepos simplify sharing and syncing changes – for instance, a design system component in `packages/ui` can be imported by both the web and native app. Tools like Turborepo help coordinate builds across the repo. Both Expo and Next can be configured to work in such a setup (Expo’s docs have guidance for Yarn workspaces, and Next’s transpile configuration can include the shared packages).

* **Shared Business Logic:** Aim to write business logic (state management, API calls, validation, etc.) in a platform-agnostic way and put it in the shared packages. For example, form validation rules or data fetching code should not care if it’s running on web or mobile. This not only reduces duplication but ensures consistent behavior. One can even implement an abstraction layer (sometimes called a “gateway” or service layer) that all apps use to fetch and manipulate data. Real-world teams have successfully shared complex logic across platforms – for instance, the same Redux or Zustand store powering both web and mobile, or identical data caching using libraries like TanStack Query on all platforms.

* **Platform-Specific Extensions:** Despite the “one codebase” ideal, some platform-specific code is often necessary for polish. React Native supports platform-specific files (e.g., `Component.ios.tsx`, `Component.android.tsx`, `Component.web.tsx`) which the bundler will pick per platform. Use this to implement small differences in UI or behavior. For example, you might have a `<Button>` that on web shows a hover tooltip, while on mobile it does not – this could be handled by a `.web.tsx` file adding the tooltip code. Keep these differences minimal and well-organized. As a strategy, many teams create a base component and extend it per platform only when needed. The Theodo engineering team recommends this “base + platform-specific overrides” pattern to maintain consistency while adapting to each platform’s needs.

* **Responsive Design & Layout:** One of the hardest things to share is layout structure, especially when your web app needs a completely different layout for large screens. For instance, a web dashboard might use a multi-column layout, whereas the mobile app of the same product would use a single-column scroll with drawers or tabs. In such cases, it’s often wise to **diverge at the layout level** but keep inner components the same. You can have a `MainScreen.web.tsx` that composes components in a web-friendly layout, and `MainScreen.mobile.tsx` for the native stack layout. As one expert noted, *“the components are shared and look very similar, but the layout is fundamentally different depending on the platform”*. Designing your app in terms of reusable components (header, feed item, etc.) that can be arranged differently per platform yields the best balance of code reuse and UX quality.

* **Navigation and Routing:** Navigation differs greatly between web (URL-driven, possibly SSR-based routing) and native (stack and tab navigators). Solutions like **Expo Router** attempt to unify this with file-based routes for both, but as mentioned, it may fall short for complex web needs. Another approach is to use a library like **Solito**, which allows you to define navigation intents in a shared way – essentially mapping a URL to either a Next.js page or a React Navigation action. With Solito, your screens can live in the shared code and each platform handles how to navigate to them (web via linking, native via navigation stack). At the very least, ensure your deep linking scheme and route structure is planned so that features can be accessed on all platforms via some route or navigation path.

* **Unified Styling and Design System:** Maintaining a consistent look across platforms is easier if you use a cross-platform compatible styling solution. You can use RN’s `StyleSheet` or CSS-in-JS that works in both environments. Libraries like **Tamagui** go a step further by providing a unified styling system and a set of UI primitives that perform well on native and web, even compiling styles for optimization. Tamagui’s approach of a “unified UI system and compiler” enables a high degree of code sharing without sacrificing performance. Other UI libraries (NativeBase, React Native Paper) also support web and native out-of-box. The goal is to avoid maintaining separate style codebases. Tokens like colors, spacing, etc., should be defined once (possibly in a shared JSON or TS file) and used everywhere for consistency.

* **Testing and CI/CD:** A universal app should also have a unified testing strategy. Consider using cross-platform testing tools or separate suites for web and mobile that leverage the same test cases where possible. For deployment, you’ll need different pipelines (web to Vercel or similar, mobile to App Store/Play Store via EAS or Fastlane, desktop packaging via Electron-builder or similar). A monorepo can help coordinate versioning. Some boilerplates integrate CI workflows to build all targets on a push, which can be very effective.

## Comparison of Key Tools & Frameworks

To summarize the roles and trade-offs of the various tools in a universal React stack, the table below compares key frameworks and approaches:

| **Tool / Framework**              | **Role in Stack**                                                    | **Code Sharing**                                                                                                                                                                                           | **Pros**                                                                                                                                                                                                                                                                                            | **Cons**                                                                                                                                                                                                                                                                                                                     | **Community & Usage**                                                                                                                                                                                                                                                    |
| --------------------------------- | -------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **React Native** (core)           | Mobile UI framework (iOS, Android); can be extended to Windows/macOS | High for mobile platforms (iOS & Android share 90%+ UI code; logic 100%)                                                                                                                                   | Native UI = great performance and feel on mobile; large ecosystem of libraries; “write once, run anywhere” for mobile. Also used beyond mobile (e.g. Messenger Desktop).                                                                                                                            | Not designed for web by itself; requires bridging (RN Web) for browser. Some native modules or heavy graphics need optimization.                                                                                                                                                                                             | **Very large community.** Backed by Meta; used in thousands of apps (Facebook, Instagram, Shopify). Mature for mobile; Windows/macOS support is official (by Microsoft) but community is smaller there.                                                                  |
| **React Native for Web**          | RN compatibility layer for Web                                       | High – allows *most* RN components and APIs to run on web (often \~80%+ of code shared across web & native)                                                                                                | Enables true cross-platform UI sharing (web, mobile, desktop) from one codebase. No need to maintain a separate React DOM app. Many RN libraries work on web via RNW.                                                                                                                               | Not all native features available in web (e.g. no direct access to certain device APIs). Some web-specific UX (responsive layout, hover) require platform-specific adjustments.                                                                                                                                              | **Active project**, created by a core React team member. Used in production by Twitter, Flipkart, MLS, etc.. Maintainers keep it updated with React Native releases.                                                                                                     |
| **Expo** (managed RN)             | Dev toolchain and SDK for RN (mobile & web)                          | Very high for mobile (Expo *is* RN) and also shares code with web (via RNW). Expo’s web support can reuse essentially all JS code; just lacks SSR.                                                         | Easiest onboarding – no native build setup needed. Rich module ecosystem (sensors, push, etc.) out of the box. **Web/PWA support with zero config**. Fast iteration (hot reload), OTA updates.                                                                                                      | Web capabilities limited (no built-in SSR) – not ideal for SEO-heavy projects without Next. Adding unsupported native modules requires ejecting. App size slightly larger due to included SDK.                                                                                                                               | **Very popular in RN community.** Thousands of apps start with Expo (e.g., Ignite and Obytes starters use Expo). Great documentation and active forums. Used for both prototypes and some production apps.                                                               |
| **Next.js**                       | Web framework (SSR, routing, bundling)                               | Shares React components and logic with RN app (via monorepo); only UI differences separate them. Web and mobile can reuse business logic 100% and UI components largely, if built in a cross-platform way. | Best-in-class web performance and SEO (SSR/SSG). Powerful dev experience for web (fast refresh, route prefetching). Can integrate RN components for unified design system. Huge ecosystem of plugins (analytics, auth, etc.).                                                                       | Does not natively understand React Native components – needs configuration (Expo adapter, etc.). Running parallel dev servers (web and native) adds complexity. Some RN-specific components (e.g. certain gestures) might not have a web analog.                                                                             | **Extremely large community.** Widely adopted for web apps across industries. Combining Next with RN (the **T3 Turbo** approach) is growing in popularity, thanks to examples and monorepo starters. Long-term support by Vercel ensures continuous improvements.        |
| **Electron**                      | Desktop app shell using web code                                     | 100% reuse of web code for desktop (essentially wraps your web app as-is)                                                                                                                                  | Single codebase covers Windows, macOS, Linux. Can use any web library on desktop. Access to Node.js APIs for native features. Proven at scale (apps like VSCode, Slack run on Electron). Lots of tooling for packaging, auto-updates.                                                               | High memory and storage footprint – each app bundles a Chromium instance. Performance can suffer on low-end devices or with heavy UI (since it’s not using native UI controls). Not a good choice for very graphics-intensive apps (e.g. high-end games, complex 3D).                                                        | **Widespread usage.** Major community and many plugins (for installers, native menus, etc.). Maintained by OpenJS Foundation. Despite criticisms about app size, it remains the go-to for cross-platform desktop in JS.                                                  |
| **RN Windows/macOS**              | React Native *extensions* for native desktop UIs                     | High sharing with core RN code (non-UI logic nearly 100%; UI components can be shared but often need tweaks for desktop paradigms)                                                                         | True native desktop apps – better performance and closer native look-and-feel than Electron (uses actual Windows/macOS UI components). Officially supported by Microsoft, with good docs and integration into RN CLI. Leverages RN skills for desktop.                                              | Smaller ecosystem – not all mobile RN libraries work on Windows/Mac out of the box. Requires Windows and Xcode development environments. UI adaptation needed (keyboard/mouse interactions, windowing) which can reduce the effective code sharing.                                                                          | **Growing niche community.** Used internally at Microsoft (e.g. Office, Teams) and by some open-source apps. If targeting Windows-specific features or needing efficiency, it’s a compelling option, but far fewer developers use it compared to Electron.               |
| **Capacitor + React** (web-first) | Web app packaged for native via WebView (alternative approach)       | Nearly 100% shared code between web, iOS, Android (the app *is* the same web UI in all cases). Desktop can also use the same web bundle (via Electron or as a PWA).                                        | Maximum code reuse – one HTML/React codebase for all platforms. Leverages web skills entirely. Capacitor provides plugins for native device access (geolocation, notifications, etc.) while still using Web tech. Simple deployment (web app can be updated without app store for content changes). | Runs in a WebView on mobile – performance and UI feel depend on web tech capabilities. Lacks the native look and performance edge of RN (especially noticeable in complex animations or very hardware-intensive features). Might hit limitations for certain native-heavy features (though plugins cover many common needs). | **Moderate community.** Ionic/Capacitor is a well-established platform (descended from Cordova/PhoneGap days). Many apps (especially enterprise or internal apps) use Ionic. However, for top-tier consumer apps, this approach is less common due to the UX trade-offs. |

**Table:** Comparison of tools for a universal React codebase, highlighting their roles, code-sharing potential, pros/cons, and adoption.

## Recommendations and Example Stacks

Given the analysis, the **most effective architecture** for a universal React project is one that **combines the strengths of React Native for native apps and a robust web framework, while leveraging code-sharing libraries and desktop packaging as needed**. In practice, a few stack combinations have emerged as front-runners:

* **Expo + React Native + Next.js (Monorepo)** – *Recommended for many scenarios.* This stack uses React Native (with Expo) for iOS/Android and Next.js (with React Native for Web) for the web. The apps live in a monorepo and share a common set of UI components and modules. This gives you truly native mobile apps and an SSR-capable web app. Code sharing is maximized: teams report being able to share **60-80% of UI code** and virtually **all business logic** between web and mobile with this setup. The Next.js app ensures your web users get a fast, indexable site, while Expo streamlines mobile development with its SDK and tooling. Libraries like Solito can be added to synchronize navigation routes between Next and React Navigation, and a design system like Tamagui or NativeBase can unify the look and feel. The **“T3 Turbo”** repo (Next + Expo + tRPC, etc.) is a great starting template, and Expo’s official docs also provide an example template (`create-expo-app -e with-nextjs`) for this integration. This approach is being successfully used in production by startups and some mid-size companies, offering an excellent balance of code reuse and platform optimization.

* **Pure Expo (React Native) across Web and Mobile** – *Best for app-centric products or when SEO is not important.* If your “web” target is more of an installable PWA or a web app that users log into (as opposed to a public content-heavy site), you might get by with Expo’s universal app without involving Next.js. Expo’s Webpack configuration will bundle your app for the web, and you can even publish it as a static site or PWA. This keeps everything truly in one app project. Developers love the simplicity (one dev server, one build process). For example, internal tools or B2B SaaS products often don’t require SSR; an Expo web build could be sufficient. Keep in mind, however, that you’ll lack server-side rendering – meaning poorer SEO and possibly slightly slower first load for very large app bundles. Still, for a tightly controlled environment, pure Expo can be a low-overhead path to cover web, Android, and iOS with one codebase.

* **React (CRA or Next) + Capacitor + Electron** – *Web-first alternative.* If your team is web-focused or you already have a React web app and want to extend to mobile/desktop quickly, consider this approach. You maintain a single React DOM codebase. Use **Capacitor** to deploy it to mobile (wrapping it in a WebView, with plugins for any needed native functionality), and use **Electron** to create desktop apps from it. This approach was suggested in some developer forums for those who “really want a desktop app” without learning new frameworks. The upside is near-100% code reuse and a unified development paradigm. The downside, as discussed, is that the mobile app is essentially a web app – it may not feel as slick as a true native app (though modern web views and devices are quite powerful). Performance on desktop is generally fine for most apps, but Electron will consume more memory than a native app. Choose this stack if maximum code sharing is your top priority and your app’s UI/UX can be made acceptable with web technologies alone. Many productivity apps have succeeded with this strategy, and with proper optimization it can serve well (e.g., using service workers, optimizing bundle size, etc., can mitigate some performance concerns on web and Electron).

* **Adding Desktop with Electron vs. RN Windows:** For desktop support, the **simplest path is to reuse the web app in Electron**. This is what most universal React stacks do, since it requires minimal extra development – essentially just creating an Electron main process that loads your web bundle. However, if your desktop app needs to behave more natively (e.g. a heavy-duty enterprise app or one that must conform to OS-specific UI guidelines), you might invest in **React Native for Windows/macOS**. This would involve writing some desktop-specific code (particularly for UI layout – e.g., using menus, resizable windows, etc.), but you could still share a lot of core logic with your mobile app. The community feedback is that RN for desktop can achieve better performance than Electron (since it’s not running a full browser), but it’s more complex to set up. A middle ground some take is to do both: deliver an Electron app quickly for all platforms, and for one platform where performance is critical (say, Windows), later swap in a RN-Windows implementation. For most cases, though, **Electron is recommended** due to its maturity and extensive tooling – the overhead is usually acceptable given modern PC specs, and developer productivity is high.

### Real-World Examples

* **Tesla** (unconfirmed tech stack): Rumors have it that the new Tesla mobile app leverages React Native. If Tesla wanted to unify their web and desktop experiences, an RNW + Electron approach could allow their engineering team to share code across the in-car display app, mobile app, and a potential desktop management app. This type of unified strategy is increasingly attractive for companies with a broad device ecosystem.

* **Discord**: Discord’s desktop app is built with Electron, while its mobile apps use React Native. They do not use a single codebase for all three, but they *do* share design and maybe some business logic across platforms. If starting Discord from scratch today, one might architect it with more shared code – perhaps using RN for Web to share UI components between the Electron (desktop) app and mobile app, reducing the duplication. This highlights that even successful multi-platform products often evolve toward convergence over time.

* **Banking/Finance Apps**: Some banks have chosen a unified web and mobile codebase using Ionic/Capacitor for rapid development. Over time, a few have switched to React Native for better performance on mobile while keeping web separate. A hybrid approach is also possible: use React Native for the consumer-facing mobile apps (for superior native feel), but use a web-based approach for internal admin desktops or web portals (for maximal reuse). The right choice can differ per use-case, but the technologies we discussed can be mixed-and-matched as needed within a single organization’s ecosystem.

## Conclusion

Building a universal React project that truly delivers on all platforms is an achievable goal today. The key is to **leverage the right combination of tools**: use React Native to get close-to-native mobile and even desktop apps, use React Native for Web (possibly via Expo) to extend that code to the browser, and incorporate Next.js if server-side rendering and advanced web capabilities are required. For desktop, Electron offers a quick win to package your web app for users on Windows, Mac, and Linux. Each tool comes with trade-offs, but when combined thoughtfully, they let you maximize code sharing without severely compromising on user experience.

In our research, the **Expo + React Native + Next.js** stack in a monorepo emerged as a strong solution for many products – it’s backed by a robust community and proven in real-world use. This stack allows a small team to deliver a **fully consistent app** across web, iOS, and Android, and even desktop via Electron, from one codebase. Companies adopting this approach benefit from faster development (no need to implement features three times) and easier maintenance (bug fixes and updates propagate to all platforms).

However, one must also remain pragmatic: absolute “write once, run anywhere” is a lofty ideal. In practice, **“learn once, write *somewhere*”** might be more accurate – you learn a single tech stack (React/JS), but you still write platform-specific code where it makes sense. The goal is to share what can be shared (business logic, state management, most UI components) and isolate what cannot (certain layouts, native integrations) cleanly. By following the architecture patterns and utilizing the frameworks discussed, you can minimize redundancy and achieve a maintainable, universal codebase.

**References:** The insights and data in this report are drawn from expert blogs and documentation. For example, Mo Khazali’s 2023 talk on **Building Universal Apps in React Native** highlights how companies like Twitter and Flipkart successfully use RN for Web to unify platforms. The LogRocket guide on RN for Web details the mechanics and benefits of this approach. Stackademic’s 2024 overview compares Next.js, Expo, Tamagui, Expo Router, and Capacitor in the context of universal React apps. Finally, cross-platform performance and community adoption notes were verified via React Native’s official showcase and industry comparisons. These sources (cited throughout) provide further reading for those looking to dive deeper into specific aspects of multi-platform React development.
